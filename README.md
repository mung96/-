**1.컴파일러와 인터프리터**

컴퓨터가 프로그래밍 언어를 이해하는 방식은 2가지

1) **컴파일러** : 소스파일(코드) → 실행파일(기계어) → 실행 (번역과 느낌이 비슷함)

2) **인터프리터**: 소스파일 → 실행 (동시통역과 느낌이 비슷함)

**2.데이터,메모리,변수**

데이터: 값

메모리: 데이터가 위치하는 공간

변수:메모리 공간의 이름 (메모리주소는 너무 어렵잖아)

**3.= vs ==**

a = 10 : 오른쪽→왼쪽으로 할당 (초기화라고 부름)

a == 10 : 등호의 의미 (파이썬에서 같다는 ==로 쓴다는 것을 기억)

**4.변수작성법**

-영문 권장

-첫번째는 소문자로 (Class 명을 첫번째 대문자로 하거든. 이거랑 구분하려고)

-카멜 or 스네이크로 사용

 -특수문자는 _외에 사용금지

-공백문자 사용 금지 

-숫자는 사용가능하지만 처음에는 안됨

**5.자료형**

효율적인 메모리를 사용하기 위해 자료형을 지정한다. 

→방을 8칸줬는데 데이터가 6칸이면 비효율이잖아. 그래서 효율적으로 방관리를 위해 자료형을 지정 →파이썬은 데이터 적으면 알아서 판단

-정수, 실수, 불린, 문자

-정수는 무한자릿수, 실수는 17,18번째 까지만 가능 이후는 짤림

-’’를 찍으면 무조건 문자열

- casting : 자료형변환
    
    int(실수)→소숫점 버림
    
    bool(문자)→있으면 True, 비었으면 False ⇒주의) 공백도 문자가 있는거임, bool(’False’)=True 임
    
    str(False)=’False’, bool(’False’)=True
    

-/연산하면 무조건 실수형

-input함수의 결과는 무조건 문자열, 그래서 앞에 casting해줘야함.

- 문자열과 변수를 같이 출력하는 방법
    - ,  or + 를 이용한 연속출력
    - f’ {변수명} 문자 {변수} ‘
    - ‘{0}, {1},{0}’.format (a,b)

\t ⇒ 탭, \n ⇒개행

**6.형식문자**

%s ⇒ 문자열

%d ⇒ 정수

%.f ⇒실수 (.f=.0f)

**7.연산자**

숫자와 문자는 덧셈이 불가능하다.

문자의 덧셈은 가능하나 뺼셈은 불가능하다.

/: 나누기, //:몫, %:나머지

divmod(num1,num2) ⇒(몫,나머지) 튜플반환

-format(숫자, ‘,’) ⇒숫자에 1000마다 , 찍은 문자열 반환

포매팅 : 문자열을 예쁘게 만들어주는 과정

-한줄에 변수 연속 선언시 ,가 아니고 ;

-비교연산자의 결과는 bool이다.

-문자 비교연산은 아스크코드로 한다. ord, char

**8.조건문**

-문자열은 ==, !=만 가능하다. 

-엑셀 : if(조건식,A,B) 

파이썬: A if 조건식 else B

-if, for, while 문에서 pass는 아직 실행문을 정하지 못했으니 넘어가라는 뜻

-소수자리만 지칭하는 법: num - int(num)

-조건식은 모두 조건문으로 바꿀 수 있다. 그 역은 성립하지 않음

-조건문에 실행문이 길다면 조건식으로 바꿀 수 없다.

-조건문 작성시 순서를 신경쓰거나 or 범위를 구체적으로 명시하거나

-elif는 수평관계, 중첩if는 수직관계네⇒중첩if는 3-4개까지만 쓴다.

-의사코드: 프로그램 작성전에 논리를 작성하는 것

**9.반복문**

-횟수가 지정되면 for문, 조건이 지정되면 while문

-while True: ⇒무한 루프

continue부터 정리

출처 입력

**10.기타**

- 소수자리만 지칭하는 법: num - int(num)
- 의사코드: 프로그램 작성전에 논리를 작성하는 것
- format(숫자, ‘,’) ⇒ 숫자에 1000마다 , 찍은 문자열 반환
- 포매팅 : 문자열을 예쁘게 만들어주는 과정
- 따옴표 여러개여도 숫자
- for else 사용시 break면 else도 실행 안함. else도 반복문의 일부느낌이네

**컨테이너 자료형:** 여러개의 데이터가 묶여있는 자료형

1.**리스트**

list.reverse ⇒ 리스트 순서 뒤집기(아무것도 반환하지 않음)/  reversed(list)도 가능

리스트를 뒤집는 다른 방법 : list[::-1]

list.index(값) ⇒값의 인덱스를 반환

list.count(값) ⇒ 리스트에서 값의 갯수를 세줌

for문에 반복자 두 개 쓰면 알아서 리스트안의 리스트를 지정.(튜플안의 튜플지정)

list.clear() ⇒모든 값 제거

- 예시
    
    ```python
    scores1 = [['국어',58],['영어',77],['수학',89]]
    scores2 = (('국어',58),('영어',77),('수학',89))
    
    for sub, score in scores1:
        print(sub,score)
    
    for sub, score in scores2:
        print(sub,score)
    ```
    

2.**튜플**

튜플은 선언시 괄호 생략 가능

tuple(), list() 로 자료형 전환 가능

- 리스트 vs 튜플
    
    ![슬라이드1.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1d02e298-f5c7-44b9-9a34-d497beb5fbde/%E1%84%89%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%83%E1%85%B31.jpeg)
    

3.딕셔너리

딕셔너리.get(키) ⇒ 값을 찾아줌. 키가 없어도 에러가 발생하지 않고 none를 반환

딕셔너리.keys() ⇒ 키들을 반환

딕셔너리.values() ⇒ 값들을 반환

딕셔너리.items() ⇒(키, 값)들을 반환

딕셔너리.pop(키) ⇒ 값 삭제

딕셔너리.clear() ⇒모든 아이템 삭제

del 딕셔너리[키] ⇒ 제거

4.**기타**

문자열.replace(a,b,횟수) ⇒a를 b번 횟수만큼 바꿔줌

**1.함수**

**return**을 만나면 실행이 종료됨 => return 아래 있는 내용은 무의미

**전역변수**: 외부에서 선언, 전체 사용 가능

**지역변수**: 함수 내부에서 선언, 내부에서만 사용가능

**지역변수, 전역변수 케이스**

**case1**: 지역변수 선언이 없으면 전역변수를 가져다 사용

- 예시
    
    ```python
    num = 10
    def calculate():
       print(num + 20)  #num에 전역변수 10이 들어감
    ```
    

**case2**: 전역변수와 지역변수 명이 같아도 다른 취급을 받음

- 예시
    
    ```python
    num = 10
    def calculate():
       num = 20
       print(num + 20)  #num에 지역변수 20이 들어감
    ```
    |  |  |
| --- | --- |
| list.append() |  |
|  |  |

**case3**: 함수 안에서 전역변수 변경을 원하면 global 키워드 사용

- 예시
    
    ```python
    num = 10
    
    def calculat():
       global num
       num = 20
    
    print(num)  #20이 출력됨
    ```
    

**lambda** 키워드 : 한 문장으로 함수선언

- 예시
    
    ```python
    lambda 키워드 : 한 문장으로 함수선언
    func = lambda n1,n2: n1 + n2
    (함수명 = lambda 변수선언 : 함수식)
    ```
    

**2.모듈, 패키지**

- 사용자 모듈을 만들고 싶으면 그냥 파이썬 파일을 만들면 됨
- **from~import** 로 특정 기능만 넣어줄수도있다.

```python
from 모듈 import 기능
from 모듈 import * =>모듈의 모든 기능을 임포트
from 모듈 import 기능1, 기능2 => 여러개 기능 동시에 가능
```

**__name__** => 실행파일이라면 '__main__' 이 아니라면 모듈이름이 저장되는 전역변수

import 시 모듈이 자동실행되는데 이때 **if __name__ =='__main__':** 으로 조건문을 사용하면

실행파일일때만 실행하는 구문 생성이 가능하다.

**패키지**: 모듈 모음 => 모듈이름이 같아도 패키지 이름이 다르면 구분가능

사용할 모듈은 같은 패키지에 있어야 하지만 **site-packages**에 들어있다면 어디서든 사용가능

**3. 객체, 클래스**

- 객체 = 속성(__init__생성자)과 기능으로 구성
- 객체 생성시 __init__() 가 자동호출
- 변수에 객체 메모리를 저장함 => 내용 복사가 아니라 주소 복사이기 때문에 한쪽이 바뀌면 전부 바뀜

```python
rb1 = class()
rb2 = rb1 =>rb1, rb2는 같은 내용으로 수정됨
```

**얕은 복사**: 주소를 복사 =>' =' 이용

**깊은 복사**: 내용까지 복사 => copy 이용

```python
import copy
tc1 = class()
tc2 = copy.copy(tc1)
```

- **super()** =>부모 클래스를 부른다.

```python
def __init__():
   super.__init__(a,b) => 부모 클래스에 있는 속성값을 여기서 초기화하겠다!

오버라이딩 : 자식 클래스에서 부모 클래스 함수를 다시 정의
def fire():
   super.fire()  => 이 클래스에서 fire()기능을 다시 정의할건데 부모의 fire()를 일단 호출해
```

**추상클래스**: 상위클래스에 메소드 이름정도만 적고 하위클래스에 메소드 구현을 강제하는 방법

3가지 필요 => ABCMeta, abstractmethod 임포트, metaclass=ABCMeta, @abstractmethod

```python
from abc import ABCMeta, abstractmethod

class AirPlane(metacass=ABCMeta):
    @abstractmethod
    def flight()
```

**4. 예외**

```python
try: #예외가 뜨면 처리하라는 신호탄

except: #예외발생시 다음과 같이 처리

else: #예외가 발생하지 않는다면 실행, except: 가 반드시 필요

finally: # 항상 처리하는 부분
```

**5. 파일 쓰기**

```python
file = open('경로', '모드')
```

모드 w =>경로에 파일이 없으면 생성이 됨

file.write 하면 글자수가 return됨

```python
with open() as f: =>close 하지 않아도 됨.
```

f.writelines() => 리스트를 for문 없이 읽어옴

f.readlines() => 텍스트를 개행 기준 리스트형태로 반환

6.**기타**

random.sample

```python
random.sample(range(1,101),10)
```

sys 모듈 =>시스템에 관한 모듈

```python
for path in sys.path: 를 해주면 경로가 나옴
```

sum, max, min 리스트인자 넣으면 알아서 계산해줌

enumerate(리스트) => 이터러블한 (index,value)를 반환

list.pop()=>마지막 인덱스 값 제거

**최대공약수, 최소공배수**

-유클리드 호제법

:x,y의 최대공약수는 y, x%y의 최대공약수와 같다.⇒ x%y가 0이 되면 y가 최대공약수 ⇒코딩은 스왑을 이용

-최대공약수 * 최소공배수 = 두 수의 곱

**진법**

16진법 ⇒ 0~9+ A~F 사용

bin,oct,hex함수 사용

```python
num = 30
print('2진수로 변경:{}'.format(bin(num)))
print('8진수로 변경:{}'.format(oct(num)))
print('16진수로 변경:{}'.format(hex(num)))
print('10진수로 변경:{}'.format(int('0b101')))
```

문자 포매팅 format(숫자, 진법)

```python
# case1
num = 30
print('2진수로 변경:{}'.format(format(num,'#b')))
print('8진수로 변경:{}'.format(format(num,'#o')))
print('16진수로 변경:{}'.format(format(num,'x')))

#case2
num1= 30
num2 = 40
print('2진수: {0:b},8진수: {1:#o},16진수: {0:#x},'.format(num1,num2))
```

프로그램 = 미리 작성된 것

컴퓨터는 이진 코드만 이해 가능. 하지만 이진코드로 명령하기 너무 어려워서 프로그래밍 언어 탄생.프로그래밍 언어로 작성한 프로그램 = 소스코드. 소스코드를 이진언어로 바꿔주는 코드실행기

파이썬은 모든 운영체제에서 사용 가능

파이썬은 느려서 머신러닝을 할 때 전체적인 프로그램은 파이썬으로 고정된 연산부분은 C언어로 만들기도 함.

표현식 < 문장 < 프로그램

표현식 = 값(=리터럴)을 가지는 단위, 프로그램 기본단위

키워드: 파이썬에서 이미 예약된 언어

식별자: 변수 or 함수 이름

식별자

캐멀케이스 (무조건 대문자로 시작/ 클래스 이름에 사용)

스네이크 케이스(무조건 소문자로 시작/함수, 변수에 사용)

함수 : 어떤 처리를 하는 식별자/ ()가 붙음

변수: 어떤 값을 저장하는 식별자

자료 = 어떤 상태를 가지고 있는 것

이스케이프 문자 : \기호와 함께 조합해서 사용하는 특수문자

\” 큰따옴표 의미 , \’작은따옴표 의미. \\ \를 의미

파이썬은 여러 줄 문자열이라는 기능을 지원 작은따옴표, 큰따옴표 연속 3번찍으면 됨.

줄바꿈 하기 싫은 구간에는 \ 삽입

자료형별 연산자 정리하기

수, 수 +,-,*,/,//,%,비교연산자

문자, 문자 : +, ==, ! =, <,>,+=

문자, 숫자: *, *=가환

문자열 연산자

[]: 인덱싱=특정 위치의 문자를 참조하는 것

[:]슬라이싱 = 문자열 일부를 추출하는 것

문자열.upper()⇒대문자로 변경

문자열.lower()⇒소문자로 변경

문자열.strip() ⇒ 양 옆에 공백 제거

문자열.find(”안녕”) ⇒왼쪽부터 ‘안녕’위치 찾기

문자열.rfind(”안녕”) ⇒오른쪽부터 ‘안녕’위치 찾기

부동소수점: 표현 방식을 바꿀 수 있다는 의미

정수, 실수의 기준은 소수점을 찍었느냐로 판단

e2 = x10^2 을 의미

프롬프트 문자열: input함수 안에 있는 문자열

블록: 프로그램 실행 도중에 잠시 멈추는 것. input사용하면 코드 블록

짝수를 만든는 방법

if num[-1] in “02468:

False 반환 ⇒ None, 0, 빈컨테이너

제너레이터:  한번쓰면 없어짐

리스트.reversed() ⇒ 제너레이터 반환

리스트 이름 = [표현식 for 반복자 in 반복할 수 있는 것 if 조건문]

⇒반복문도 반복식 형태로 가능, 콜론을 안써도 돼

문자1.join([a,b,c]) ⇒ a+문자1+b+문자1+c +문자1

함수의 매개변수

일반매개변수 , 가변매개변수, 기본매개변수, 키워드 매개변수

가변과 기본은 맨뒤에 써야함⇒그래야 일반 매개변수 숫자만큼 자리 채우고 그 이후로 기본,가변 처리해야하니까. ⇒기본,가변을 동시에 쓰려면 키워드 매개변수

키워드 매개변수 사용시 기본 매개변수는 아무위치에나 써도 됨 ⇒그래서 matplotlib에서 그렇게 맘대로 썼구나. 라이브러리에 쓰던게 다 기본매개변수구나.

재귀함수와 메모화

재귀함수쓰면 같은 함수를 다시계산할때가 있음. 그래서 딕셔너리에 메모해놓고 시작

- 피보나치 메모화 코드
    
    ```python
    cnt2 = 0
    fib = {1: 1, 2: 1}
    
    def fibonaci2(n):
        global cnt2
        cnt2 += 1
        if n in fib:
            fibo = fib[n]
            return fibo
        else:
            fibo = fibonaci2(n - 1) + fibonaci2(n - 2)
            fib[n] = fibo
            return fibo
    ```
    

텍스트함수 open,close

파일이 프로그램으로 오는 길을 뚫어주는 함수, 스트림을 열고 닫는다는 표현을 사용

filter와 map으로 함수를 매개변수로 전달

map(함수, 리스트***)⇒ 리스트 모든 요소를 함수에 적용해서 결과 반환

filter(함수, 리스트) ⇒ 리스트 모든 요소를 함수에 넣고 T,F 반환

map 함수는 여러 리스트를 받는데 왜 filter함수는 안되지?

구문오류 : 실행 전에 발생하는 오류, 예외처리(try~except)가 안됨.

예외, 런타임오류: 실행 중에 발생하는 오류

예외처리법 2가지

기본예외처리: 조건문 사용⇒예외상황을 정의해야함.

try-except:예외 상황을 몰라도 됨.

 ⇒예외실행문이 중요하지 않지만 종료를 막아야할때 일단 except처리

finally구문의 유용한 점: return이나 break를 만나도 무조건 실행됨

except를 이용해 if,elif처럼 예외별로 실행문 작성 가능

```python
except 예외의 종류 as 예외 객체 변수명:
except IndexError as e:
```

어떤 예외일지 모를 때는 Exception 클래스 활용

```python
except Exception:
```

객체  = 여러가지 속성을 가질 수 있는 대상

인스턴스 = 클래스로 만들어진 객체

인스턴스 만들때는 클래스 이름과 같은 함수를 사용

클래스

생성자: 클래스() ⇒실행시 자동으로 **init** 아래가 실행됨

```python
class Class:
	def __init__(self):
		self.dic={}

Class() => #자동으로 __init__이 실행
```

메소드: 클래스에서의 함수

isinstance(인스턴스, 클래스)로 해당 클래스로 만든 인스턴스인지 T,F 반환

(자식클래스로 만든 인스턴스, 부모클래스)여도 True로 반환

기타

import datetime

datetime.datetime.now() ⇒ 현재를 가져오는 방법 .year등으로 해당 내용 불러와

time.localtime 과는 반환하는 자료형이 다른건가?

time은 시간과 관련된 모듈, datetime은 날짜와 관련된 모듈

데몬=서비스:항상 켜져있는 프로그램
